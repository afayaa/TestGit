Mysql中有哪些存储引擎
    Innodb
    mysql默认的事务型引擎，也是最重要、使用最广泛的存储引擎，它被设计用来处理大量的短期(short-lived)事务,应该优先
    考虑Innodb引擎

    MyISAM
    在mysql5.1及之前的版本，MYyISAM是默认的存储引擎
    但是MyISAM不支持事务和行级锁，而且崩溃后无法安全恢复。同时MyIASM对整张表加锁，很容易因为表锁的问题导致典型的性能问题

    Memory引擎
    Memory表至少比MyISAM表快一个数量级，数据文件是存储在内存中。
    Memory表的结构在重启以后还会保留，但数据会丢失
    Memory表在很多场景可以发挥好的作用：
    用于查找(lookup)或者映射(mapping)表，例如将邮编和地区名映射的表
    用于缓存周期性聚合数据的结果
    用于保存数据分析中产生的中间数据

    Archive引擎
    Archive存储引擎只支持insert和select操作，会缓存所有的写并利用zlib对插入的行进行压缩，所以比MyISAM表的磁盘I/O更少
    但是每次select查询都需要执行全表扫描。所以Archive表适合日志和数据采集类应用

    CSV引擎
    CVS引擎可以将普通的CVS文件(逗号分割值文件)作为Mysql的表来处理，但这种表不支持索引，因此CVS引擎可以作为一种数据交换
    的机制，非常有用



MyISAM和InnoDB的区别是什么
    1、InnoDB支持事务，MyIsAm不支持事务。
        这是Mysql将默认存储引擎从MyISAM变成InnoDB的重要原因之一
    2.InnoDB支持外键，而MyISAM不支持
        对一个包含外键的InnoDb表转为MyISAM会失败
    3.InnoDB是聚集索引(主键)，MyISAM是非聚集索引
    数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

        聚集索引的文件存放在主键索引的叶子节点上，因此InnoDB必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，
        先查询到主键，然后再通过主键查询到数据，因此，主键不应该过大，因为主键太大，其他索引也会很大。
        而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。
    4.InnoDB不保存表的具体行数，执行select count(*) from table 时需要全表扫描，MyISAM用一个变量保存了整个表的行数
    5.InnoDB最小的锁粒度是行锁，MyISAM是表锁
        一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限，这也是Mysql将默认存储引擎从MyISAM
        变成InnoDB的重要原因之一


数据库表设计时，字段你会如何选择
    1.字段类型优先级
    整型>date,time>enum char > varchar > blob,text
    选用字段长度最小、优先使用定长型、数值型字段中避免使用"zerofill"。
    time：定长运算快，节省时间，考虑时区，写sql不方便
    enum：能约束值的目的，内部用整型来存储，但与char联查时，内部要经历串与值的转化
    char：定长，考虑字符集和校对集(索引排序用到)
    varchar：不定长，要考虑字符集的转换与排序时的校对集，速度慢
    text，blob：无法使用内存临时表(排序操作只能在磁盘上进行)
    注意：date，time的选择可以直接选择使用时间戳，enum("男","女") 内部转成数字来存储，多了一个转换的过程，可以使用tinyint
    代替最好使用tinyint
    2.可以选整型就不选字符串
    整型是定长的，没有国家/地区之分，没有字符集差异。例如：tinyint 和char(1)从空间上看都是一字节，但是order by 排序tinyint
    快，原因是后者需要考虑字符集与校对集
    3.够用就行不要慷慨
    大的字段影响内存相应速度，以年龄为例，tinyint unsigned not null;可以存储255岁，足够了，用int浪费3个字节。以varchar(10),
    varchar(300)存储的内容相同，但在表中查询时，varchar(300)要花费更多内存
    4.尽量避免使用NULL
    null不利于索引，也不利于查询。=null 或者 !=null都查询不到值，只有使用 is null 或者 is not null 才可以。因此可以在创建字段
    的时候使用 not null default "" 的形式。
    5.char与varchar的选择
    char长度固定，处理速度要比varchar快很多，但是相对较浪费存储空间，所以对存储空间要求不大，但在速度上有要求的可以使用char，反之
    可以用varchar



Mysql中varchar(M)最多能存储多少数据
    对于varchar(M)类型的列最多可以定义65535个字节(一般 utf-8 编码下，一个汉字字符占用3个字节)其中的M代表该类型最多存储的
    字符数量，但在实际存储时并不能放这么多。
    Mysql对一条记录占用的最大存储空间是有限制的，除了BLOB或者TEXT类型的列之外，其他所有的列(不包括隐藏列和记录头信息)占用的
    字节长度加起来不能超过65535字节


Mysql索引
    mysql索引按字段特性分类可分为:主键索引、普通索引、前缀索引
    1.主键索引： 建立在主键上的索引被称为主键索引，一张表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。
    2.唯一索引：建立在unique字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突
    3.普通索引：建立在普通字段上的索引被称为普通索引
    4.前缀索引：前缀索引是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀
    索引可以建立在char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。
    前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：mysql无法使用前缀索引做order by和group by


什么是三星索引
    对于一个查询而言，一个三星索引，可能是其最好的索引
    如果查询使用三星索引，一次查询通常只需要进行一次磁盘随机读以及一次窄索引片的扫描，因此其响应时间通常次使用一个普通索引少几个数量级
    把 WHERE 后的等值条件列作为索引最开头的列，（尽可能最左前缀）如此，必须扫描的索引片宽度就会缩至最短。则获得一星
    如果索引中的数据顺序order by和查找中排列顺序一致则获得两星
    如果索引列中包含了查询中需要的全部列则获得三星
    三星索引在实际的业务中如果无法同时达到，一般我们认为第三颗星最重要，第一和第二颗星差不多，根据业务情况调整



如何提高insert的性能
    1.合并多条insert为一条
    即 insert into t values(a,b,c),(d,e,f)...
    原因分析：主要原因是多条insert合并日志量(Mysql的binlog和innodb的事务日志)减少了，降低日志刷盘的数据量和频率，从而提高效率，
    通过合并sql，同时也能减少sql语句解析的次数，减少网络传输的IO。
    2.修改参数 bulk_insert_buffer_size,调整批量插入的缓存；
    3.设置innodb_flush_log_at_trx_commit = 0
        相对于innodb_flush_log_at_trx_commit = 1 可以很明显的提升导入速度；innodb_flush_log_at_trx_commit参数解释如下：
        0：log buffer中的数据将以每秒一次的频率写入到log file中，且同时会进行文件系统到磁盘的同步操作，但是每个事务的commit并不会
        触发任何log buffer到log file的刷新或者文件系统到磁盘的刷新操作；
        1：在每次事务提交的时候将log buffer中的数据写入到log file，同时也会触发文件系统到磁盘的刷新操作；
        2：事务提交会触发log buffer 到log file的刷新，但并不会触发文件系统到磁盘的刷新操作。此外，每秒会有一次文件系统到磁盘的刷新操作。
    4.手动使用事务：
    因为mysql默认是autocommit的，这样每插入一条数据，就会进行一次commit，



什么是全局锁，共享锁，排他锁
    全局锁就是对整个数据库实例加锁，它的经典使用场景就是做全库逻辑备份，这个命令可以使整个库处于只读状态，使用该命令之后，数据更新语句、
    数据定义语句、更新类事务的提交语句等操作都会被阻塞
    共享锁又被称为读锁，是读取操作创建的锁，其他用户可以并发读取数据，但任何事务都不能对数据进行修改(数据数据上的排它锁)，直到已释放所有
    共享锁，如果事务对读锁进行修改操作，很可能会造成死锁。
    select xxx LOCK IN SHARE MODE  读加锁
    排它锁：又称写锁，若某个事务对某一行加上了排它锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他
    进程可以读取，不能进行写操作，需要等待其释放，排它锁是悲观锁的一种实现
    innoDB默认给insert update delete加排它锁
    select xxx FOR UPDATE 读加排它锁


Mysql如何实现读写分离
    就是将mysql的数据copy多份，写到其它的mysql服务器上，原来mysql数据库负责写(主库)其他mysql数据库只负责读(从库)


分库分表
    水平拆分  hash拆分(uuid)，时间拆分(时间字段)  mycat分库分表中间件




索引 原理：就是把无序的数据变成有序的查询

索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。
1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据



mysql聚簇索引和非聚簇索引的区别
    都是B+树
        聚簇索引：将数据存储与索引放到了一块，并且是按照一定的顺序组织的，找到了索引也就找到了数据，数据的物理存放顺序与索引顺序是
    一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的
        非聚簇索引：叶子结点不存放数据，存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本书
    的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。

    优势：
    1.查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询(非覆盖索引的情况下)效率要高
    2.聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的
    3.聚簇索引适合用在排序的场合，非聚簇索引不适合

    劣势：
    1.维护索引很昂贵，特别是插入新行或者主键被更新导致要分页的时候。建议在大量插入新行后，选择在负载较低的时间段，通过OPTIMIZE TABLE
    优化表，因为必须被移动的行数据可能造成碎片，使用独享表空间可以弱化碎片
    2.表因为使用uuid(随机ID)作为主键，使数据存储稀疏，这就会出现聚簇索引可能比全表扫描更慢，所以建议使用int的auto_increment作为主键
    3.如果主键比较大的话，那辅助索引将会变得更大，因为辅助索引的叶子存储有主键值，过长的主键值，也会导致非叶子节点占用更多的物理空间

Innodb一定有主键，主键一定是聚簇索引，不手动设置，则会使用unique索引，没有unique索引，则会使用数据库内部的一个隐藏id来当做主键索引
在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引、
辅助索引的叶子节点存储的是索引字段信息和主键值。


如果涉及到大量数据的排序、全表扫描、count之类的操作的话，还是MyISAM占优势，因为索引所占空间小，这些操作是需要在内存中完成的



Mysql索引的数据结构，各自优劣
    索引的数据结构和具体存储引擎的实现有关，在Mysql中使用较多的有Hash索引，B+树索引，Innodb存储引擎的默认索引实现为B+树索引。
对哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，
建议使用B+树索引

    B+树是一种平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针互相链接。在B+树的常规检索，从根节点
到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高，因此，B+
树索引被广泛应用于数据库，文件系统等场景。

    哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需要一次哈希算法
就可立即定位到相应的位置，速度非常快
    如果是等值查询，那么哈希索引有绝对优势，因为只需要经过一次算法即可找到相应的键值，前提是键值都是唯一的，如果键值不是唯一的，就需要
先找到该键所在的位置，在根据链表往后扫描，知道找到相应的数据；
    如果是范围检索，原先有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索，哈希索引也没有办法
利用索引完成排序，以及like'xxx%'这样的部分模糊查询(本质上也是范围查询)；哈希索引也不支持多列联合索引的最左匹配原则；(多个字段映射
成一个hash值)
    B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题




索引设计的原则
    查询更快、占用空间更小
    1.适合索引的列是出现在where子句中的列，或者连接子句中指定的列
    2.基数较小的列，索引效果较差，没有必要在此列建立索引
    3.使用短索引，如果对长字符串进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除
不匹配的行，然后检查其余行是否可能匹配
    4.不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能，在修改表内容的时候，索引会进行更新甚至重构，索引列越多，时间越长。
所以只保持需要的索引有利于查询即可。
    5.定义有外键的数据列一定要建立索引
    6.更新频繁字段不适合创建索引
    7.若是不能有效区分数据的列不适合做索引(性别：男 女 未知，区分度太低)
    8.尽量扩张索引，不要新建索引，比如将a索引改成(a,b)索引
    9.对于那些查询中很少涉及的列，重复值比较多的列不要建立索引
    10.对于定义为text、image和bit的数据类型的列不要建立索引




Mysql锁的类型有哪些
    基于锁的属性分类：共享锁，排他锁
    基于所得粒度分类：行级锁(Innodb)、表级锁(MyISAM)、页级锁(bdb引擎)、记录锁、间隙锁、临键锁。
    基于锁的状态分类：意向共享锁、意向排他锁
        共享锁(share lock)
        共享锁又称读锁，简称S锁：当一个事务为数据加上该锁后，其他事务只能对该数据加读锁，而不能对数据加写锁，知道所有的读锁释放之后
    其他事务才能对其加持写锁，共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读问题

        排他锁(exclusive lock)
        排它锁又称写锁，简称x锁：当一个事务为数据加上写锁是，其他请求将不能为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行
    加锁，排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取，避免了出现脏数据和脏读的问题

        表锁
        表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能对表进行访问
        特点：力度大，加锁简单，容易冲突

        行锁
        行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能被访问，其他的记录是可正常访问
        特点：粒度小、加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；

        记录锁(record lock)
        记录锁也属于行锁的一种，只不过记录锁的范围之是表中的某一条记录
        精准条件命中，并且命中的条件字段是唯一索引
        加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务提交前被其他事务读取的脏读问题。

        页锁
        页级锁是mysql中锁定粒度介于行级锁和表级锁中间的一种锁，表级锁速度快，但冲突多，行级锁冲突少，但速度慢，所以取了折中的页级
        一次锁定相邻的一组记录
        特点：开销和加锁时间介于表锁和行锁之间，会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般

        间隙锁
        属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵守左开右闭原则。
        范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在repeatable_read(重复度)的事务级别中。
        触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生以下问题，在同一个事务里，A事务的两次查询结果会不一样
        如表里面的数据ID为 1,4,5,7,10,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间

        临键锁
        也是属于行锁的一种，并且它是innodb行锁默认算法，总结来说他就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会
        把该返回查询内的所有间隙空间也锁住，在之后他会把相邻的下一个区间也锁住
        触发条件：范围查询并命中，查询命中了索引
        结合记录锁和临键锁的特性，临键锁避免了在范围查询是出现脏读、重复度、幻读问题，加了临键锁之后，在范围区间内数据不允许被修改和插入


        如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整张表加共享锁或排他锁了，那么
        后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个结点扫描是否加锁，而这个状态
        就是意向锁

        意向共享锁
        当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁

        意向排他锁
        当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁



Mysql执行计划
    执行计划就是sql的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数
    EXPLAIN select * from A where x=? and y=?
    id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra
    1. id:是一个有顺序的编号，是查询的顺序号，有几个select就显示几行。id的顺序是按select出现的顺序增长的。id列的值越大执行优先级越高，
    id列的值相同则从上往下执行，id列的值为null则最后执行。
    2.select_type 表示查询中每个select子句的类型
        SIMPLE：表示此查询不包含UNION查询或子查询
        PRIMARY：表示此查询是最外层的查询(包含子查询)
        SUBQUERY：子查询中的第一个select
        UNION：表示此查询是UNION的第二或随后的查询
        DEPENDENT UNION：UNION中的第二个或后面的查询语句，取决于外面的查询
        UNION RESULT：UNION的结果
        DEPENDENT SUBQUERY：子查询中的第一个select，取决于外面的查询，即子查询依赖于外层查询的结果
        DERIVED：衍生，表示导出表的select(from 子句的子查询)

    3.table：表示该语句查询的表
    4.type：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标，它的取值类型范围：
        const：通过索引一次命中，匹配一行数据
        system：表中只有一行记录，相当于系统表
        eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配
        ref：非唯一性索引扫描，返回匹配某个值的所有
        range：只检索给定范围的行，使用一个索引来选择行，一般用于between、<、>
        index：只遍历索引树
        all：表示全表扫描，这个类型的查询是性能最差的查询之一，那么基本就是随着表数据增多，执行效率月慢
        执行效率：all<index<range<ref<eq_ref<const<system 最好避免all和index

    11：extra
        using filesort：表示mysql对结果集进行外部排序，不能通过索引顺序达到排序效果，一般有using filesort都建议优化去掉，因为
        这样的查询cpu资源消耗大，延时大。
        using index：覆盖索引扫描，表示查询在索引树中就可以查找所需数据，不用扫描表数据文件，往往说明性能不错。
        using temporary：查询有使用临时表，一般出现于排序，分组和多表join的情况，查询效率不高，建议优化
        using where：sql使用了where过滤，效率较高。


怎么处理慢查询
    在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们

    慢查询的优化首先要搞明白慢的原因是什么，是查询条件没有命中索引，是load了不需要的数据列，还是数据量太大
    所以优化也是针对这三个方向来的，
    首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析和重写
    分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句尽可能的命中索引
    如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以横向或者纵向分表


ACID靠什么保证的
    A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
    C一致性由其他三大特性保证，程序代码要保证业务上的一致性
    I隔离性由MVCC来保证
    D持久性由内存+redo log来保证，mysql修改数据库同时在内存和redo log记录这次操作，宕机时可以从redo log恢复

    InnoDB redo log 写盘，InnoDB事务进入prepare状态，如果前面prepare成功，binlog写盘，再继续将事务日志持久化到bin log，
    如果持久化成功，那么InnoDB事务则进入commit状态(在redo log里面写一个commit 记录)
    redo log的刷盘会在系统空闲时进行

什么是MVCC
    快照其实是指向保存在存储设备中的数据的引用标记或指针，说穿了就是数据在某一时刻的状况，其工作原理核心就是是建立一个指针列表，
    指示读取数据的地址，提供一个瞬时数据的影像，当数据有改变时，再进行复制。

    多版本并发控制：读取数据时通过一种类似于快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务session会看到自己特定
    版本的数据，版本链

    MVCC只在RC 和RR两个隔离级别下工作，其他两个隔离级别和MVCC不兼容，因为RU 总是读取最新的数据行，而不是符合当前事务版本的数据行，
    而serializable则会对所有读取的行加锁

    聚簇索引记录中有两个必要的隐藏列：
    trx_id：用来存储每次对某条聚簇索引记录进行修改的事务ID。
    roll_pointer:每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中，这个roll_pointer就是存放了一个指针，它指向这条
    聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息(注意插入操作的undo日志没有这个属性，因为它没有老版本)

    已提交读和可重复读的区别就在于他们生成readview的策略不同


    Read View几个属性
    trx_ids: 当前系统活跃(未提交)事务版本号集合。
    low_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。
    up_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”
    creator_trx_id: 创建当前read view的事务版本号；



    版本链
    id | name | trx_id | roll_pointer
    1  | 小明2 | 100   | 上一个版本地址
    1  | 小明1 | 60    | 上一个版本地址
    1  | 小明  | 50    |

    开始事务时创建readview，readview维护当前活动的事务id，即未提交的事务id，排序生成一个数组
    访问数据，获取数据中心的事务id(获取的是事务id最大的记录)，对比readview；
    如果在readview的左边(比readview都小)，可以访问(在左边意味着该事务已经提交)
    如果在readview的右边(比readview都大)，或者就在readview中，不可以访问，获取roll_pointer，取上一版本重新对比(在右边意味着，
    该事务在readview生成之后出现，在readview中意味着该事务还未提交)

    已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的readview，而可重复读隔离级别则在第一次读的时候生成一个readview，之后
    的读都复用之前的readview

    这就是mysql的MVCC，通过版本链，实现多版本，可并发读写，写读。通过readview生成策略的不同实现不同的隔离级别


Mysql主从同步原理
    mysql主从同步过程：
    Mysql的主从复制中主要由三个线程，master（binlog dump thread）、slave（I/O thread、sql thread），master一条线程和slave中的
    两条线程。
    主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构
    或内容的一个文件。
    主节点 log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从结点。
    从节点I/O线程接受binlog内容，并将其写入到relay log文件。
    从节点的sql线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性。
注：主从节点使用binlog文件+position偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从
    position的位置发起同步。
    由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，
    这时候从库升为主库后，日志就丢失了。由此产生两个概念。
    1 全同步复制
    主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。
    2 半同步复制
    和全同步不同的是，半同步复制的逻辑是这样的，从库写入日志成功后返回ack确认给主库，主库受到至少一个从库的确认就认为写操作完成